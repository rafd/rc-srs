<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RC Learning Game</title>
    <style>
        body { font-family: sans-serif; background-color: #f0f0f0; margin: 0; padding: 20px; display: flex; justify-content: center; align-items: center; min-height: 100vh; }

        #game-container { width: 100%; max-width: 600px; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); text-align: center; }
        .challenge-target { margin-bottom: 30px; }
        .challenge-target img { width: 250px; height: 250px; border-radius: 12px; object-fit: cover; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .challenge-target .target-name { font-size: 2.5em; font-weight: bold; color: #333; }

        .options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .option-btn { padding: 20px; font-size: 18px; cursor: pointer; border: 2px solid #eee; border-radius: 8px; background: #fff; transition: all 0.2s; font-weight: 500; }
        .option-btn:hover:not(:disabled) { background: #f8f9fa; border-color: #ddd; transform: translateY(-2px); }
        .option-btn.correct { background: #d4edda; border-color: #28a745; color: #155724; }
        .option-btn.incorrect { background: #f8d7da; border-color: #dc3545; color: #721c24; cursor: not-allowed; opacity: 0.7; }

        .image-option { width: 100%; height: 180px; object-fit: cover; border-radius: 8px; border: 4px solid transparent; cursor: pointer; transition: all 0.2s; }
        .image-option:hover { transform: scale(1.02); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .image-option.correct { border-color: #28a745; background: #d4edda; }
        .image-option.incorrect { border-color: #dc3545; opacity: 0.4; cursor: not-allowed; }

        .loading { font-size: 1.2em; color: #666; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-content">
            <div class="loading">Loading RC Profiles...</div>
        </div>
    </div>

    <script type="module">
        import { FSRS, Rating, generatorParameters, createEmptyCard } from 'https://esm.sh/ts-fsrs@4.3.1';

        const fsrs = new FSRS(generatorParameters());
        let allProfiles = [];
        let cardStates = JSON.parse(localStorage.getItem('rc-memory-game-cards') || '{}');
        let currentCardInfo = null;
        let hasErroredOnCurrent = false;

        function saveStates() {
            localStorage.setItem('rc-memory-game-cards', JSON.stringify(cardStates));
        }

        function getCard(profileId, type) {
            const key = `${profileId}:${type}`;
            if (!cardStates[key]) {
                cardStates[key] = createEmptyCard();
            }
            // Ensure dates are actual Date objects after JSON.parse
            const card = cardStates[key];
            card.due = new Date(card.due);
            card.last_review = card.last_review ? new Date(card.last_review) : undefined;
            return card;
        }

        async function initGame() {
            const container = document.getElementById('game-content');
            const proxyUrl = '/api/directory';

            try {
                const response = await fetch(proxyUrl);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                // Filter profiles that have both name and image
                allProfiles = data.filter(p => p.name && p.image_path);

                if (allProfiles.length >= 4) {
                    startNewChallenge();
                } else {
                    container.innerHTML = '<p>Not enough profiles to start a game.</p>';
                }
            } catch (error) {
                console.error('Fetch error:', error);
                container.innerHTML = `<p>Error loading data: ${error.message}</p>`;
            }
        }

        function startNewChallenge() {
            const now = new Date();

            // 1. Identify all possible cards (2 per profile)
            const allPossibleCards = [];
            allProfiles.forEach(p => {
                allPossibleCards.push({ profile: p, type: 'face-to-name' });
                allPossibleCards.push({ profile: p, type: 'name-to-face' });
            });

            // 2. Find due cards or new cards
            const dueCards = allPossibleCards.filter(c => {
                const card = getCard(c.profile.id, c.type);
                return card.due <= now && card.state !== 0; // State 0 is New
            });

            const newCards = allPossibleCards.filter(c => {
                const card = getCard(c.profile.id, c.type);
                return card.state === 0;
            });

            let selected;
            if (dueCards.length > 0) {
                // Pick the most overdue card
                selected = dueCards.sort((a, b) => {
                    const cardA = getCard(a.profile.id, a.type);
                    const cardB = getCard(b.profile.id, b.type);
                    return cardA.due - cardB.due;
                })[0];
            } else if (newCards.length > 0) {
                // Pick a random new card
                selected = newCards[Math.floor(Math.random() * newCards.length)];
            } else {
                // Everything is reviewed and not yet due, pick the one due soonest
                selected = allPossibleCards.sort((a, b) => {
                    const cardA = getCard(a.profile.id, a.type);
                    const cardB = getCard(b.profile.id, b.type);
                    return cardA.due - cardB.due;
                })[0];
            }

            const { profile: correctPerson, type: challengeType } = selected;
            currentCardInfo = selected;
            hasErroredOnCurrent = false;

            // Find distractors with same pronouns
            let potentialDistractors = allProfiles.filter(p =>
                p.id !== correctPerson.id &&
                p.pronouns === correctPerson.pronouns
            );

            if (potentialDistractors.length < 3) {
                const others = allProfiles.filter(p =>
                    p.id !== correctPerson.id &&
                    p.pronouns !== correctPerson.pronouns
                );
                const shuffledOthers = others.sort(() => 0.5 - Math.random());
                potentialDistractors = potentialDistractors.concat(shuffledOthers.slice(0, 3 - potentialDistractors.length));
            }

            const distractors = potentialDistractors
                .sort(() => 0.5 - Math.random())
                .slice(0, 3);

            const options = [correctPerson, ...distractors].sort(() => 0.5 - Math.random());

            renderChallenge(challengeType, correctPerson, options);
        }

        function renderChallenge(type, correct, options) {
            const container = document.getElementById('game-content');
            container.innerHTML = '';

            const targetDiv = document.createElement('div');
            targetDiv.className = 'challenge-target';

            if (type === 'face-to-name') {
                targetDiv.innerHTML = `<img src="${correct.image_path}" alt="Who is this?">`;
            } else {
                targetDiv.innerHTML = `<div class="target-name">Who is ${correct.name}?</div>`;
            }
            container.appendChild(targetDiv);

            const optionsGrid = document.createElement('div');
            optionsGrid.className = 'options-grid';

            options.forEach(option => {
                if (type === 'face-to-name') {
                    const btn = document.createElement('button');
                    btn.className = 'option-btn';
                    btn.textContent = option.name;
                    btn.onclick = () => handleChoice(btn, option.id === correct.id);
                    optionsGrid.appendChild(btn);
                } else {
                    const img = document.createElement('img');
                    img.src = option.image_path;
                    img.className = 'image-option';
                    img.onclick = () => handleChoice(img, option.id === correct.id);
                    optionsGrid.appendChild(img);
                }
            });

            container.appendChild(optionsGrid);
        }

        function handleChoice(element, isCorrect) {
            if (isCorrect) {
                element.classList.add('correct');

                // Update FSRS state
                const now = new Date();
                const card = getCard(currentCardInfo.profile.id, currentCardInfo.type);
                const rating = hasErroredOnCurrent ? Rating.Again : Rating.Good;
                const schedulingCards = fsrs.repeat(card, now);

                // Update state
                const key = `${currentCardInfo.profile.id}:${currentCardInfo.type}`;
                cardStates[key] = schedulingCards[rating].card;
                saveStates();

                // Disable all options in the grid
                const allOptions = element.parentElement.children;
                for (let opt of allOptions) {
                    opt.onclick = null;
                    if (opt !== element) {
                        opt.style.opacity = '0.5';
                        opt.style.pointerEvents = 'none';
                    }
                }

                // Move to next challenge after a short delay
                setTimeout(startNewChallenge, 1000);
            } else {
                element.classList.add('incorrect');
                element.onclick = null;
                element.style.pointerEvents = 'none';
                hasErroredOnCurrent = true;
            }
        }

        // Initialize the game on load
        initGame();
    </script>
</body>
</html>
